#include "stdafx.h"

#include "DeviceFloppy.h"
#include <array>
#include <FileUtil.h>

using hscommon::fileUtil::File;
using emul::GetBit;
using emul::SetBit;
using emul::GetMSB;
using emul::SetLSB;

namespace fdd
{
	static constexpr std::array<BYTE, 6> SYNC_FIELD = { 0xFF, 0x3F, 0xCF, 0xF3, 0xFC, 0xFF };
	static constexpr std::array<BYTE, 3> HEADER_BEGIN = { 0xD5, 0xAA, 0x96 };
	static constexpr std::array<BYTE, 3> HEADER_END = { 0xDE, 0xAA, 0x00 };
	static constexpr std::array<BYTE, 3> DATA_BEGIN = { 0xD5, 0xAA, 0xAD };
	static constexpr std::array<BYTE, 3> DATA_END = { 0xDE, 0xAA, 0x00 };

	static constexpr BYTE EncodingTable6and2[] = {
		0x96, 0x97, 0x9A, 0x9B, 0x9D, 0x9E, 0x9F, 0xA6,
		0xA7, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB2, 0xB3,
		0xB4, 0xB5, 0xB6, 0xB7, 0xB9, 0xBA, 0xBB, 0xBC,
		0xBD, 0xBE, 0xBF, 0xCB, 0xCD, 0xCE, 0xCF, 0xD3,
		0xD6, 0xD7, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE,
		0xDF, 0xE5, 0xE6, 0xE7, 0xE9, 0xEA, 0xEB, 0xEC,
		0xED, 0xEE, 0xEF, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6,
		0xF7, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
	};

	BYTE GetHigh2(const BYTE b) { return b & 0b11000000; }
	BYTE GetLow6(const BYTE b) { return b & 0b00111111; }

	// TODO: temp
	static constexpr SectorData sector0 {
		{ 0 },
		{
			0x4C, 0x4B, 0x60, 0x00, 0x00, 0x86, 0x00, 0x12, 0x00, 0x00, 0x06, 0x53, 0x79, 0x73, 0x74, 0x65,
			0x6D, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x06, 0x46, 0x69, 0x6E, 0x64, 0x65,
			0x72, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x07, 0x4D, 0x61, 0x63, 0x73, 0x62,
			0x75, 0x67, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0C, 0x44, 0x69, 0x73, 0x61, 0x73,
			0x73, 0x65, 0x6D, 0x62, 0x6C, 0x65, 0x72, 0x20, 0x20, 0x20, 0x0D, 0x53, 0x74, 0x61, 0x72, 0x74,
			0x55, 0x70, 0x53, 0x63, 0x72, 0x65, 0x65, 0x6E, 0x20, 0x20, 0x06, 0x46, 0x69, 0x6E, 0x64, 0x65,
			0x72, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0E, 0x43, 0x6C, 0x69, 0x70, 0x62,
			0x6F, 0x61, 0x72, 0x64, 0x20, 0x46, 0x69, 0x6C, 0x65, 0x20, 0x00, 0x0A, 0x00, 0x14, 0x00, 0x00,
			0x43, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x22, 0x38, 0x01, 0x08, 0x48, 0x41,
			0x0C, 0x41, 0x00, 0x04, 0x6E, 0x2C, 0x72, 0x00, 0x50, 0xF9, 0x00, 0x01, 0xFF, 0xF0, 0x42, 0xB9,
			0x00, 0x03, 0xFF, 0xF0, 0x4A, 0xB9, 0x00, 0x01, 0xFF, 0xF0, 0x67, 0x16, 0x70, 0x02, 0x48, 0x40,
			0xD1, 0xB8, 0x01, 0x08, 0xD1, 0xB8, 0x08, 0x24, 0xD1, 0xB8, 0x02, 0x66, 0xD1, 0xB8, 0x01, 0x0C,
			0x72, 0x04, 0x20, 0x78, 0x02, 0xA6, 0x0C, 0x41, 0x00, 0x08, 0x6F, 0x02, 0x72, 0x08, 0xD1, 0xFB,
			0x10, 0xAE, 0x2F, 0x08, 0x70, 0x07, 0x41, 0xF8, 0x0A, 0xB8, 0x42, 0x98, 0x51, 0xC8, 0xFF, 0xFC,
			0x34, 0x3A, 0xFF, 0x9A, 0x70, 0x16, 0xC0, 0xC2, 0x22, 0x00, 0xA7, 0x1E, 0x43, 0xF8, 0x01, 0x54,
			0x53, 0x42, 0x32, 0x82, 0x42, 0xA1, 0x42, 0xA1, 0x42, 0x61, 0x23, 0x08, 0x46, 0x58, 0x55, 0x41,
			0x66, 0xFA, 0x33, 0x3C, 0xFF, 0xEF, 0x42, 0x78, 0x01, 0x84, 0x72, 0xFC, 0x70, 0x0F, 0x14, 0x38,
			0x02, 0x06, 0xC0, 0x02, 0xD0, 0x40, 0x48, 0x40, 0x10, 0x02, 0xE4, 0x48, 0xC0, 0x41, 0x48, 0x40,
			0x21, 0xC0, 0x01, 0x8E, 0x70, 0x0F, 0x14, 0x38, 0x02, 0x09, 0xC0, 0x02, 0xE5, 0x48, 0x21, 0xC0,
			0x02, 0xF4, 0x10, 0x02, 0xE4, 0x48, 0xC0, 0x41, 0x21, 0xC0, 0x02, 0xF0, 0x41, 0xF8, 0x03, 0x40,
			0x72, 0x50, 0x42, 0x58, 0x51, 0xC9, 0xFF, 0xFC, 0x70, 0x1E, 0xC0, 0xFA, 0xFF, 0x2E, 0x32, 0x38,
			0x01, 0x08, 0xE2, 0x49, 0xC0, 0xC1, 0x54, 0x40, 0x32, 0x00, 0xA7, 0x1E, 0x21, 0xC8, 0x03, 0x4E,
			0x30, 0xC1, 0x31, 0xFC, 0x00, 0x02, 0x03, 0x4C, 0x9E, 0xFC, 0x00, 0x32, 0x20, 0x4F, 0x31, 0x78,
			0x02, 0x10, 0x00, 0x16, 0xA0, 0x0F, 0x66, 0x00, 0x01, 0xB2, 0xDE, 0xFC, 0x00, 0x32, 0x43, 0xF8,
			0x0A, 0xD8, 0x41, 0xFA, 0xFE, 0x86, 0x70, 0x10, 0xA0, 0x2E, 0x55, 0x4F, 0x2F, 0x0F, 0x48, 0x78,
			0x09, 0xFA, 0x20, 0x78, 0x08, 0x10, 0x4E, 0x90, 0x30, 0x1F, 0xE6, 0x48, 0x31, 0xC0, 0x01, 0x06,
			0x08, 0x38, 0x00, 0x06, 0x02, 0x0B, 0x56, 0xF8, 0x08, 0xD3, 0xA8, 0x52, 0x43, 0xFA, 0xFE, 0x9C,
			0x76, 0x01, 0x61, 0x00, 0x01, 0x98, 0x0C, 0x44, 0x40, 0x00, 0x6E, 0x02, 0x70, 0xFF, 0x3F, 0x00,
			0x66, 0x04, 0x61, 0x00, 0x01, 0xF0, 0xA8, 0x53, 0x55, 0x4F, 0x42, 0xB8, 0x0A, 0xF2, 0xA9, 0x95,
			0x4A, 0x5F, 0x6B, 0x00, 0x01, 0x56, 0x3E, 0x1F, 0x20, 0x5F, 0xA0, 0x57, 0x21, 0xF8, 0x02, 0xA6,
			0x01, 0x18, 0x59, 0x4F, 0x2F, 0x3C, 0x44, 0x53, 0x41, 0x54, 0x42, 0x67, 0xA9, 0xA0, 0x2A, 0x1F,
			0x67, 0x00, 0x01, 0x1E, 0x20, 0x45, 0x21, 0xD0, 0x02, 0xBA, 0xA8, 0xFE, 0x70, 0x28, 0x61, 0x00
		}
	};

	static constexpr SectorData sector1 {
		{ 0 },
		{
			0x01, 0x16, 0x20, 0x3C, 0x00, 0x00, 0x06, 0x00, 0x32, 0x3A, 0xFD, 0xFE, 0x67, 0x0A, 0x6A, 0x04, 
			0x70, 0x01, 0xE2, 0x58, 0x91, 0xB8, 0x01, 0x0C, 0x04, 0xB8, 0x00, 0x00, 0x04, 0x00, 0x01, 0x0C, 
			0x43, 0xFA, 0xFE, 0x08, 0x61, 0x00, 0x01, 0x24, 0x66, 0x00, 0x00, 0xF4, 0x4E, 0x91, 0x70, 0xF6, 
			0x61, 0x00, 0x00, 0xE4, 0x43, 0xFA, 0xFE, 0x04, 0x61, 0x00, 0x01, 0x10, 0x66, 0x08, 0x4E, 0x91, 
			0x70, 0xF5, 0x61, 0x00, 0x00, 0xD2, 0x43, 0xF8, 0x0A, 0xD8, 0x76, 0xFF, 0x61, 0x00, 0x00, 0xFE, 
			0x66, 0x00, 0x00, 0x04, 0x4E, 0x91, 0x21, 0xF8, 0x02, 0xA6, 0x02, 0xB2, 0x70, 0x0C, 0xA7, 0x22, 
			0x21, 0xC8, 0x0A, 0xEC, 0xA0, 0x2C, 0xA0, 0x4F, 0x2F, 0x05, 0xA9, 0xA3, 0x7C, 0x00, 0x59, 0x4F, 
			0x2F, 0x3C, 0x49, 0x4E, 0x49, 0x54, 0x3F, 0x06, 0xA9, 0xA0, 0x2E, 0x17, 0x67, 0x00, 0x00, 0x64, 
			0xA9, 0x92, 0x20, 0x47, 0x20, 0x50, 0x4E, 0x90, 0x20, 0x47, 0x20, 0x50, 0x30, 0x3C, 0x4E, 0x71, 
			0x30, 0xC0, 0x30, 0xC0, 0x52, 0x46, 0x0C, 0x46, 0x00, 0x20, 0x6D, 0xD2, 0x70, 0x02, 0x48, 0x40, 
			0xA4, 0x4C, 0x43, 0xF8, 0x09, 0x70, 0x21, 0xC9, 0x09, 0x6C, 0x41, 0xFA, 0xFD, 0xBE, 0x70, 0x10, 
			0xA0, 0x2E, 0x41, 0xFA, 0xFD, 0x66, 0x43, 0xF8, 0x02, 0xE0, 0x70, 0x10, 0xA0, 0x2E, 0x42, 0x78, 
			0x09, 0x00, 0x47, 0xFA, 0xFD, 0x96, 0x61, 0x6A, 0x67, 0x08, 0x47, 0xFA, 0xFD, 0x4E, 0x61, 0x62, 
			0x66, 0x0A, 0x42, 0x67, 0x42, 0xA7, 0x2F, 0x0B, 0x20, 0x4F, 0xA9, 0xF2, 0x70, 0x29, 0xA9, 0xC9, 
			0xA9, 0xFF, 0x58, 0x4F, 0x60, 0xAE, 0x61, 0x08, 0x20, 0x79, 0x00, 0x40, 0x00, 0x04, 0x4E, 0xD0, 
			0x9E, 0xFC, 0x00, 0x32, 0x20, 0x4F, 0x31, 0x7C, 0xFF, 0xFB, 0x00, 0x18, 0x31, 0x7C, 0x00, 0x07, 
			0x00, 0x1A, 0x31, 0x78, 0x02, 0x10, 0x00, 0x16, 0xA0, 0x04, 0xDE, 0xFC, 0x00, 0x32, 0x4E, 0x75, 
			0x7E, 0x00, 0x60, 0x00, 0xFE, 0xE6, 0x4A, 0x47, 0x67, 0x02, 0xA9, 0xC9, 0x4E, 0x75, 0x06, 0xB8, 
			0x00, 0x00, 0x04, 0x00, 0x01, 0x0C, 0x60, 0x00, 0xFF, 0x1E, 0x61, 0xC4, 0x70, 0x64, 0xA9, 0xC9, 
			0x60, 0xB4, 0x70, 0x13, 0x42, 0xA7, 0x51, 0xC8, 0xFF, 0xFC, 0x2F, 0x4B, 0x00, 0x12, 0x20, 0x4F, 
			0xA0, 0x0C, 0xDE, 0xFC, 0x00, 0x50, 0x4A, 0x40, 0x4E, 0x75, 0x76, 0x00, 0x9E, 0xFC, 0x00, 0x32, 
			0x20, 0x4F, 0x74, 0xFF, 0x45, 0xE8, 0x00, 0x12, 0x24, 0xC9, 0x42, 0x9A, 0x42, 0x1A, 0x14, 0xFC, 
			0x00, 0x01, 0x24, 0xBC, 0x00, 0x01, 0x10, 0x00, 0xA0, 0x00, 0x66, 0x2C, 0xA0, 0x11, 0x66, 0x26, 
			0x28, 0x1A, 0x7C, 0x02, 0xE1, 0x46, 0x98, 0x86, 0x4A, 0x43, 0x6B, 0x2E, 0x66, 0x22, 0x22, 0x78,
			0x01, 0x0C, 0x93, 0xC4, 0x24, 0xC9, 0x24, 0xC4, 0x58, 0x4A, 0x34, 0xFC, 0x00, 0x01, 0x24, 0x86, 
			0xA0, 0x02, 0x66, 0x02, 0x74, 0x00, 0xA0, 0x01, 0x30, 0x02, 0xDE, 0xFC, 0x00, 0x32, 0x4E, 0x75, 
			0x32, 0x7C, 0x60, 0x00, 0xD8, 0x86, 0x7C, 0x00, 0x60, 0xDA, 0x20, 0x04, 0xA1, 0x1E, 0x22, 0x48, 
			0x20, 0x4F, 0x60, 0xD0, 0x2F, 0x3C, 0x01, 0x56, 0x02, 0x00, 0x42, 0xA7, 0x2F, 0x3C, 0x60, 0x00, 
			0x00, 0x40, 0x42, 0x67, 0x4B, 0xF9, 0x00, 0x00, 0xFD, 0x90, 0x45, 0xED, 0x00, 0x72, 0x2F, 0x0F, 
			0x48, 0x52, 0x48, 0x6F, 0x00, 0x0E, 0x48, 0x6A, 0x00, 0x06, 0x42, 0x67, 0x42, 0xA7, 0xA8, 0xEC, 
			0xDE, 0xFC, 0x00, 0x0E, 0x4E, 0x75, 0x4C, 0x4B, 0x60, 0x00, 0x00, 0x86, 0x00, 0x14, 0x00, 0x00, 
			0x06, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
		}
	};



	BYTE Encode6and2(BYTE data) { assert(data < 64); return EncodingTable6and2[data]; }

	const char* GetStepDirectionStr(StepDirection dir)
	{
		switch (dir)
		{
		case StepDirection::OUTER: return "OUTER";
		case StepDirection::INNER: return "INNER";
		default:
			NODEFAULT;
		}
	}

	DeviceFloppy::DeviceFloppy(uint32_t clockSpeedHz, bool connected) :
		Logger("fdd"),
		m_clockSpeed(clockSpeedHz),
		m_connected(connected)
	{
		// TODO: Temp
		m_trackData.insert(m_trackData.end(), SYNC_FIELD.begin(), SYNC_FIELD.end());
		{
			DATA header = BuildHeader(0, 0, 0, DiskFormat::Mac400K);
			m_trackData.insert(m_trackData.end(), header.begin(), header.end());
			m_trackData.insert(m_trackData.end(), SYNC_FIELD.begin(), SYNC_FIELD.end());
			DATA data = BuildData(0, sector0);
			m_trackData.insert(m_trackData.end(), data.begin(), data.end());
			m_trackData.insert(m_trackData.end(), SYNC_FIELD.begin(), SYNC_FIELD.end());
		}
		{
			DATA header = BuildHeader(0, 1, 0, DiskFormat::Mac400K);
			m_trackData.insert(m_trackData.end(), header.begin(), header.end());
			m_trackData.insert(m_trackData.end(), SYNC_FIELD.begin(), SYNC_FIELD.end());
			DATA data = BuildData(1, sector1);
			m_trackData.insert(m_trackData.end(), data.begin(), data.end());
			m_trackData.insert(m_trackData.end(), SYNC_FIELD.begin(), SYNC_FIELD.end());
		}
	}

	void DeviceFloppy::Reset()
	{
		LogPrintf(LOG_INFO, "Reset");
		LogPrintf(LOG_INFO, "Clock Speed = %d, connected = %d", m_clockSpeed, m_connected);
		
		Logger::SEVERITY oldSev = GetLogLevel();
		EnableLog(LOG_OFF);

		m_diskLoaded = false;
		m_diskChanged = false;
		m_motorEnabled = false;
		m_motorPulse = false;
		m_seekCounter = UINT32_MAX;
		m_isSeeking = false;
		m_isCalibrating = false;
		m_stepDirection = StepDirection::INNER;
		m_currTrack = 0;
		m_currSector = 0;
		m_currHead = 0;

		// Set only if never uninitialized
		if (m_ticksPerRotation == UINT32_MAX)
		{
			SetMotorSpeed(DEFAULT_RPM, true);
		}

		if (m_ticksPerTrack == UINT32_MAX)
		{
			SetStepDelay(DEFAULT_STEP_MS);
		}

		ClearDiskChanged();

		EnableLog(oldSev);
	}

	void DeviceFloppy::Tick()
	{
		if (!m_connected)
			return;

		if (m_motorEnabled && (--m_motorPulseCounter == 0))
		{
			ResetPulseCounter();
			m_motorPulse = !m_motorPulse;
		}

		if (m_isSeeking && (--m_seekCounter == 0))
		{
			ResetSeekCounter();
			m_isSeeking = false;
			int newTrack = m_currTrack + (int)m_stepDirection;
			// Allow one more inner track to signify "out of bounds"
			m_currTrack = std::clamp(newTrack, 0, (int)m_trackCount); 
			if (newTrack != m_currTrack)
			{
				LogPrintf(LOG_WARNING, "Seek past endpoint");
			}

			LogPrintf(LOG_INFO, "Seek End, new track: [%d]", m_currTrack);
		}
	}

	void DeviceFloppy::EnableMotor(bool enable)
	{
		if (!m_connected)
			return;

		LogPrintf(LOG_INFO, "Motor: %s", enable ? "ON" : "OFF");

		if (enable && !m_motorEnabled)
		{
			ResetPulseCounter();
		}
		m_motorEnabled = enable;
	}

	void DeviceFloppy::SetMotorSpeed(WORD rpm, bool force) 
	{ 
		if (!force && (!m_connected || (rpm == m_motorSpeed)))
			return;

		LogPrintf(LOG_INFO, "Set Motor Speed: %d rpm", rpm);
		m_motorSpeed = std::clamp(rpm, MIN_RPM, MAX_RPM);
		if (m_motorSpeed != rpm)
		{
			LogPrintf(LOG_WARNING, "Motor Speed clamped to %d rpm", m_motorSpeed);
		}
		m_ticksPerRotation = m_clockSpeed / m_motorSpeed / 2;
		LogPrintf(LOG_DEBUG, "Ticks per Rotation: %d", m_ticksPerRotation);

		if (m_motorPulseCounter > m_ticksPerRotation)
		{
			ResetPulseCounter();
		}
	}

	void DeviceFloppy::SetHeadCount(WORD heads)
	{
		if (!m_connected)
			return;

		LogPrintf(LOG_INFO, "Set Head Count: %d", heads);
		m_headCount = std::clamp(heads, MIN_HEADS, MAX_HEADS);
		if (m_headCount != heads)
		{
			LogPrintf(LOG_WARNING, "Head Count clamped to %d", m_headCount);
		}
		m_currHead = 0;
	}
	// Heads are numbered [0..HeadCount-1]
	void DeviceFloppy::SelectHead(WORD head)
	{
		if (!m_connected)
			return;

		LogPrintf(LOG_INFO, "Select Head: %d", head);
		if (head >= m_headCount)
		{
			LogPrintf(LOG_ERROR, "Invalid Head: %d (max = %d)", head, m_headCount - 1);
			m_currHead = 0;
		}
		else
		{
			m_currHead = head;
		}
	}

	void DeviceFloppy::SetTrackCount(WORD tracks)
	{
		if (!m_connected)
			return;

		LogPrintf(LOG_INFO, "Set Track Count: %d", tracks);
		m_trackCount = std::clamp(tracks, MIN_TRACKS, MAX_TRACKS);
		if (m_trackCount != tracks)
		{
			LogPrintf(LOG_WARNING, "Track Count clamped to %d", m_headCount);
		}
		m_currTrack = 0;
	}

	void DeviceFloppy::SetStepDelay(WORD millis)
	{
		if (!m_connected)
			return;

		LogPrintf(LOG_INFO, "Set Step Delay: %d ms", millis);
		m_stepDelay = std::clamp(millis, MIN_STEP_MS, MAX_STEP_MS);
		if (m_stepDelay != millis)
		{
			LogPrintf(LOG_WARNING, "Step Delay clamped to %d ms", m_stepDelay);
		}

		m_ticksPerTrack = DelayToTicks(m_stepDelay);
		LogPrintf(LOG_DEBUG, "Ticks per Track: %d", m_ticksPerTrack);

		if (m_seekCounter > m_ticksPerTrack)
		{
			ResetSeekCounter();
		}
	}

	void DeviceFloppy::SetStepDirection(StepDirection dir)
	{ 
		if (!m_connected)
			return;

		LogPrintf(LOG_INFO, "Set Step Direction: %s", GetStepDirectionStr(dir));
		m_stepDirection = dir; 
	}

	void DeviceFloppy::Step()
	{
		if (!m_connected)
			return;

		LogPrintf(LOG_INFO, "Step one track in [%s] direction", GetStepDirectionStr(m_stepDirection));

		if (m_isSeeking)
		{
			LogPrintf(LOG_WARNING, "Step: Already seeking, ignored");
			return;
		}

		m_isSeeking = true;
		ResetSeekCounter();
	}

	BYTE DeviceFloppy::ReadByte()
	{
		static DATA::const_iterator  pos = m_trackData.begin();

		if (pos == m_trackData.end()) pos = m_trackData.begin();

		// TODO: Feed bytes at proper speed
		BYTE value = *pos++;

		LogPrintf(LOG_DEBUG, "Read Data, value = %02X", value);

		return value;
	}

	DeviceFloppy::DATA DeviceFloppy::BuildHeader(BYTE track, BYTE sector, BYTE side, DiskFormat format)
	{
		BYTE trackLow = GetLow6(track); // Bits 0..5
		bool trackHi = GetBit(track, 6); // Bit 6
		if (GetBit(track, 7))
		{
			LogPrintf(LOG_ERROR, "Track > 127, cannot be encoded in header");
			throw std::exception("Invalid track number");
		}

		if (side > 1)
		{
			LogPrintf(LOG_ERROR, "Side > 1 cannot be encoded in header");
			throw std::exception("Invalid side number");
		}

		if (sector > 63)
		{
			LogPrintf(LOG_ERROR, "Sector > 63 cannot be encoded in header");
			throw std::exception("Invalid sector number");
		}

		DATA data;
		BYTE checksum = 0;

		// Header Begin
		data.insert(data.end(), HEADER_BEGIN.begin(), HEADER_BEGIN.end());

		// Track number (low 6 bits)
		{
			checksum ^= trackLow;
			BYTE encoded = Encode6and2(trackLow);
			data.push_back(encoded);

		}

		// Sector number (6 bits)
		{
			checksum ^= sector;
			BYTE encoded = Encode6and2(sector);
			data.push_back(encoded);
		}

		// Side (and upper track bit)
		{
			BYTE sideData = 0;
			SetBit(sideData, 0, trackHi);
			SetBit(sideData, 5, side);
			checksum ^= sideData;

			BYTE encoded = Encode6and2(sideData);
			data.push_back(encoded);
		}

		// Format
		{
			checksum ^= (BYTE)format;
			BYTE encoded = Encode6and2((BYTE)format);

			data.push_back(encoded);
		}

		// Checksum
		{
			BYTE encoded = Encode6and2(checksum);
			data.push_back(encoded);
		}

		// Header End
		data.insert(data.end(), HEADER_END.begin(), HEADER_END.end());
		return data;
	}

	DeviceFloppy::DATA DeviceFloppy::BuildData(BYTE sector, const SectorData& rawData)
	{
		if (sector > 63)
		{
			LogPrintf(LOG_ERROR, "Sector > 63 cannot be encoded in header");
			throw std::exception("Invalid sector number");
		}

		DATA data;
		data.reserve(710);

		BYTE checksum = 0;

		// Header Begin
		data.insert(data.end(), DATA_BEGIN.begin(), DATA_BEGIN.end());

		// Sector number (6 bits)
		{
			checksum ^= sector;
			BYTE encoded = Encode6and2(sector);
			data.push_back(encoded);
		}

		ResetChecksum();
		// Sector Tag (12 bytes)
		{
			DATA encodedTag = EncodeDataBlock(rawData.tag, SECTOR_TAG_SIZE);
			if (encodedTag.size() != 16)
			{
				LogPrintf(LOG_ERROR, "Data Tag should encode to 16 bytes");
				throw std::exception("Invalid encoded tag size");
			}
			data.insert(data.end(), encodedTag.begin(), encodedTag.end());
		}

		// Sector Data (512 bytes)
		{
			DATA encodedData = EncodeDataBlock(rawData.data, SECTOR_DATA_SIZE);
			if (encodedData.size() != 683)
			{
				LogPrintf(LOG_ERROR, "Data Tag should encode to 683 bytes");
				throw std::exception("Invalid encoded block size");
			}
			data.insert(data.end(), encodedData.begin(), encodedData.end());
		}

		// Checksum
		{
			BYTE hiA = GetHigh2(m_checksumA) >> 2;
			BYTE hiB = GetHigh2(m_checksumB) >> 4;
			BYTE hiC = GetHigh2(m_checksumC) >> 6;

			data.push_back(Encode6and2(hiA | hiB | hiC));
			data.push_back(Encode6and2(GetLow6(m_checksumA)));
			data.push_back(Encode6and2(GetLow6(m_checksumB)));
			data.push_back(Encode6and2(GetLow6(m_checksumC)));
		}

		// Header End
		data.insert(data.end(), DATA_END.begin(), DATA_END.end());
		return data;
	}

	void DeviceFloppy::Encode3To4(BYTE encodedOut[4], BYTE byteA, BYTE byteB, BYTE byteC)
	{
		// 1. Rotate CSUMC left
		bool carry1 = ROL(m_checksumC);

		// 2. CSUMA <- CSUMA + BYTEA + carry from step 1
		bool carry2 = ADC(m_checksumA, byteA, carry1);

		// 3. BYTEA <- BYTEA xor CSUMC
		byteA ^= m_checksumC;

		// 4. CSUMB <- CSUMB + BYTEB + carry from step 2
		bool carry4 = ADC(m_checksumB, byteB, carry2);

		// 5. BYTEB <- BYTEB xor CSUMA
		byteB ^= m_checksumA;

		// 6. CSUMC <- CSUMC + BYTEC + carry from step 4
		bool carry6 = ADC(m_checksumC, byteC, carry4);

		// 7. BYTEB <- BYTEC xor CSUMB
		byteC ^= m_checksumB;

		// 8. convert BYTEA, BYTEB and BYTEC to 6 bit nibbles
		//   NIBL1 <- A7 A6 B7 B6 C7 C6 : High bits of the bytes
		//   NIBL2 <- A5 A4 A3 A2 A1 A0 : Low bits of BYTEA
		//   NIBL3 <- B5 B4 B3 B2 B1 B0 : Low bits of BYTEB
		//   NIBL4 <- C5 C4 C3 C2 C1 C0 : Low bits of BYTEC

		BYTE hiA = GetHigh2(byteA) >> 2;
		BYTE hiB = GetHigh2(byteB) >> 4;
		BYTE hiC = GetHigh2(byteC) >> 6;

		encodedOut[0] = hiA | hiB | hiC;
		encodedOut[1] = GetLow6(byteA);
		encodedOut[2] = GetLow6(byteB);
		encodedOut[3] = GetLow6(byteC);
	}

	DeviceFloppy::DATA DeviceFloppy::EncodeDataBlock(const BYTE data[], int size)
	{
		DATA encoded;

		// 3 raw bytes in -> 4 encoded bytes out
		// Work with chunks of 3 bytes
		int pos = 0;

		BYTE encodedBlock[4];
		while (pos < size)
		{
			BYTE byteA = data[pos++];
			BYTE byteB = (pos == size) ? 0 : data[pos++];
			BYTE byteC = (pos == size) ? 0 : data[pos++];

			Encode3To4(encodedBlock, byteA, byteB, byteC);

			encoded.push_back(Encode6and2(encodedBlock[0]));
			encoded.push_back(Encode6and2(encodedBlock[1]));
			encoded.push_back(Encode6and2(encodedBlock[2]));
			encoded.push_back(Encode6and2(encodedBlock[3]));
		}

		// Remove one or two encoded bytes depending on the size of the last block
		int lastBlock = size % 3;
		if (lastBlock)
		{
			encoded.resize(encoded.size() - (3 - lastBlock));
		}

		return encoded;
	}

	bool DeviceFloppy::ADC(BYTE& dest, BYTE src, bool carryIn)
	{
		int res = dest + src + carryIn;
		dest = (BYTE)res;
		return res > 0xFF;
	}
	bool DeviceFloppy::ROL(BYTE& dest)
	{
		bool rot = GetMSB(dest);
		dest <<= 1;
		SetBit(dest, 0, rot);

		return rot;
	}

	void DeviceFloppy::Serialize(json& to)
	{

	}
	void DeviceFloppy::Deserialize(const json& from)
	{

	}
}